#!/bin/bash
# Personal bash aliases and utility functions

# These are for use on development machines,
# e.g. not production machines or machines with important credentials

# Anything that could be potentially dangerous (as many Linux commands are)
# has a comment stating: "Use at your own risk!"
# Usually these will require a sudo prompt, but not always.
# I do my best to explain what could go wrong, but it may not be comprehensive.

# I denote main sections with [Section Name]
# Current sections are:
# [String Manipulation]
# [General Utilities]
# [Disk Utilities]
# [Process Monitoring]
# [Networking]

# To utilize this, add the following lines to ~/.bashrc:
# if [ -f ~/.personal_bash_aliases ]; then
#    source ~/.personal_bash_aliases
# fi

# Dependencies (not needed unless you use the corresponding aliases)
# Not necessarily a comprehensive list - depends on your system
# [orpie](https://github.com/pelzlpj/orpie)
# [xsel](https://github.com/kfish/xsel)
# [lsscsi](https://github.com/doug-gilbert/lsscsi)

# [String Manipulation]

# Debug function for checking input and output sources
# I mainly use this as a reference
function debug_check_io {
    [[ -t 1 ]] && echo 'shell is tty'
    [[ -p /dev/stdout ]] && echo 'stdout is pipe'
    [[ ! -t 1 && ! -p /dev/stdout ]] && echo 'stdout is redirect'
    [[ -f /dev/stdin ]] && echo 'stdin is file'
    [[ -p /dev/stdin ]] && echo 'stdin is pipe'
}

# Remove whitespace from a string
function strip_whitespace {
    sed 's/^[[:space:]]*//;s/[[:space:]]*$//' "$1"
}

# Remove newlines from a string
function strip_newlines {
    tr -d '\n' "$1"
}

# Wrap the input in double quotes
# If input comes from a pipe, wrap the whole contents
# Newlines get removed if reading from a pipe
function doublequote {
    if [ "$#" -gt 0 ]; then
        # Normal Args
        printf %s \""$*"\"
    elif [[ -p /dev/stdin ]]; then
        # Input from pipe
        local line
        printf '"'
        while IFS= read -r line; do
            printf %s "$line"
        done
        printf '"'
    fi
}

# Given a list of arguments, 
# produce a regex that matches a string containing all of them, in any order.
# It accomplishes matching in "any order" by matching each argument with positive lookahead
# Use at your own risk! Many cases of positive lookahead can make a really slow regex.
# Don't use this to blindly generate a regex for a production environment.
function include_list_regex {
    local ret_regex=""
    for arg in "$@"; do
        ret_regex+="(?=.${arg})"
    done
    echo "$ret_regex"
}

# [General Utilities]

# Reverse Polish Notation Calculator
alias rpn-calc='orpie'
alias rpn='orpie'

# Get the last command executed
alias last_cmd='fc -ln -1 | strip_whitespace'

# Copy the last command
alias cpl='last_cmd | strip_newlines | xsel --clipboard'

# Shortcut for clipboard, usually I pipe to this
alias clip='xclip -selection clipboard'

# Clip the working directory
alias clipwd='pwd | clip'
alias cwd='pwd | clip'

# Run a command with `sudo`, attempting to preserve aliases
# Use at your own risk! Existing commands can be overwritten by aliases,
# Thus anything ran this way may work differently than expected.
# This could also be a security risk if a non-sudo user has access
# to the sourced `.bashrc`
function sudo-with-aliases {
    sudo bash --rcfile "$HOME"/.bashrc -ci "$1"
}

# [Disk Utilities]

# Disk usage summary, human readable
alias dush='du -sh *'

# Disconnect and spin down a HDD
# Use at your own risk!
# Usage: `disconnect-hdd sdX`
function disconnect-hdd {
    local drive
    drive="$1"
    sudo umount /dev/"$drive"
    sudo hdparm -Y /dev/"$drive"
    sudo bash -c "echo 1 > /sys/block/$drive/device/delete"
}

# Scans SCSI hosts, but only if they are inactive
# Checks /sys/class/scsi_host for available hosts,
# and sees if the hosts show up in `lsscsi`
# Use at your own risk! The parsing here could definitely go belly-up
# If you scan an active device, this could interrupt reads/writes
function scan-inactive-scsi-hosts {
    local host_ids
    local raw_scsi_hosts

    raw_scsi_hosts=$(find /sys/class/scsi_host -maxdepth 1 -mindepth 1)
    host_ids=$(echo "$raw_scsi_hosts" | sed -E 's/(.+)host([0-9]+)/\2/g')

    for host_idx in $host_ids; do
        if [ -z "$(lsscsi -i "$host_idx")" ]; then
            sudo bash -c "echo '- - -' > /sys/class/scsi_host/host$host_idx/scan"
        fi
    done
}

# [Process Monitoring]

# awk to pull PID from `ps` (pipe to this, generally)
# e.g. `ps <some-heinous-condition> | awk-pid`
# For simple calls, just use `pidof`
function awk-pid {
    awk '{ print $2 }'
}

# "Ninja" meaning the grep won't return itself, primarily for process listing
function ninjagrep {
    grep "$*" | grep -v grep
}

# [Networking]

# Get the public IP via cloudflare
alias whoami-cloudflare="dig +short txt ch whoami.cloudflare @1.0.0.1"
